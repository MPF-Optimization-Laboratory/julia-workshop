<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/julia-workshop/libs/katex/katex.min.css"> <link rel=stylesheet  href="/julia-workshop/libs/highlight/styles/agate.min.css"> <link rel=stylesheet  href="/julia-workshop/css/style.css"> <link rel=icon  href="/julia-workshop/assets/favicon.png"> <title>Day 2</title> <header> <nav> <span><a href="/julia-workshop/">Home</a></span> <span><a href="/julia-workshop/day1">Day 1</a></span> <span><a href="/julia-workshop/day2">Day 2</a></span> </nav> </header> <main> <div class=franklin-content ><h1 id=day_2 ><a href="#day_2" class=header-anchor >Day 2</a></h1> <ul> <li><p><a href="/julia-workshop/day2.ipynb">Slides</a></p> <li><p><a href="/julia-workshop/problems/day2.jl">Starter code for the problems</a></p> </ul> <h2 id=problem_1_prime_number_iterator ><a href="#problem_1_prime_number_iterator" class=header-anchor >Problem 1: Prime Number Iterator</a></h2> <p>Make an iterator over the prime numbers less than or equal to <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> using a Sieve of Eratosthenes</p> <ul> <li><p>The sieve should be created when building the Primes struct</p> <li><p>You should provide a constructor which does so &#40;<code>Primes&#40;n::Int&#41;</code>&#41;</p> <li><p>The iterator interface is described <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration">here</a></p> <li><p>You may wish to define additional functions</p> </ul> <p>Sieve of Eratosthenes:</p> <ul> <li><p>Allocate a Boolean vector of size <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, where each element represents whether that number is prime.</p> <ul> <li><p>They should all start as <code>true</code>. You can use the function <code>ones&#40;Bool, n&#41;</code> to make the vector.</p> <ul> <li><p>&#40;there&#39;s also a <code>trues</code> function, which returns a <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.BitArray-Tuple&#123;Any&#125;"><code>BitVector</code></a>. This&#39;ll also work.&#41;</p> </ul> </ul> <li><p>Mark 1 as <code>false</code></p> <ul> <li><p>1 isn&#39;t prime</p> </ul> <li><p>Let <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p = 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >1</span></span></span></span></p> <li><p>While there are numbers marked as prime greater than <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>:</p> <ul> <li><p>Set <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> to the smallest number marked prime larger than the previous <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></p> <li><p>Mark all multiples of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> &#40;<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>p</mi></mrow><annotation encoding="application/x-tex">2p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8389em;vertical-align:-0.1944em;"></span><span class=mord >2</span><span class="mord mathnormal">p</span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi>p</mi></mrow><annotation encoding="application/x-tex">3p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8389em;vertical-align:-0.1944em;"></span><span class=mord >3</span><span class="mord mathnormal">p</span></span></span></span>, ...&#41; as not prime</p> </ul> <li><p>Now, all numbers are marked correctly</p> </ul> <p>Hint: <code>1:2:10</code> gives you a range over <code>&#40;1, 3, 5, 7, 9&#41;</code></p> <h2 id=problem_2_outer_product_matrix ><a href="#problem_2_outer_product_matrix" class=header-anchor >Problem 2: Outer Product Matrix</a></h2> <p>Problem 2: Write a matrix type which is the outer product of two vectors</p> <ul> <li><p>You should only store the vectors</p> <li><p>Both should have element type <code>T</code>, and it should be a subtype of <code>AbstractMatrix&#123;T&#125;</code></p> <li><p>You should implement the methods &#40;<a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array">docs</a>&#41;:</p> <ul> <li><p><code>size&#40;::OuterProduct&#41;</code></p> <li><p><code>getindex&#40;::OuterProduct, i::Int, j::Int&#41;</code></p> <li><p><code>adjoint&#40;::OuterProduct&#41;</code> &#40;hint: &#40;uv&#39;&#41;&#39; &#61; &#40;vu&#39;&#41;&#41;</p> </ul> <li><p>Try building an instance of OuterProduct in the REPL. Julia can already print it and has matrix-vector and matrix-matrix multiplication defined&#33;</p> </ul> <h2 id=problem_3_peano_arithmetic ><a href="#problem_3_peano_arithmetic" class=header-anchor >Problem 3: Peano Arithmetic</a></h2> <p><a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano arithmetic</a> provides a compact axiomatic description of the natural numbers. An informal description is:</p> <ul> <li><p>There exists 0.</p> <li><p>There exists the successor function, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy=false >(</mo><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">S()</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class=mclose >)</span></span></span></span>. <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo mathvariant=normal >≠</mo><mn>0</mn><mi mathvariant=normal >∀</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">S(x) \neq 0 ∀ x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel ><span class=mrel ><span class="mord vbox"><span class=thinbox ><span class=rlap ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class=inner ><span class=mord ><span class=mrel ></span></span></span><span class=fix ></span></span></span></span></span><span class=mrel >=</span></span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.6944em;"></span><span class=mord >0∀</span><span class="mord mathnormal">x</span></span></span></span></p> <li><p><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>=</mo><mi>S</mi><mo stretchy=false >(</mo><mi>y</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">S(x) = S(y)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mclose >)</span></span></span></span> implies <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></p> </ul> <p>From this we can recursively construct the naturals. Further, we can define addition recursively:</p> <pre><code class="julia hljs">+(<span class=hljs-number >0</span>, <span class=hljs-number >0</span>)    = <span class=hljs-number >0</span>
+(x, <span class=hljs-number >0</span>)    = x
+(<span class=hljs-number >0</span>, x)    = x
+(x, S(y)) = S(x + y)</code></pre> <p>As well as multiplication:</p> <pre><code class="julia hljs">*(<span class=hljs-number >0</span>, <span class=hljs-number >0</span>)    = <span class=hljs-number >0</span>
*(x, <span class=hljs-number >0</span>)    = <span class=hljs-number >0</span>
*(<span class=hljs-number >0</span>, x)    = <span class=hljs-number >0</span>
*(x, S(y)) = x + (x * y)</code></pre> <p>For your implementation, you&#39;ll define types and methods to compute Peano arithmetic.</p> <ul> <li><p>There should be two subtypes of <code>PeanoNumber</code>: <code>Zero</code> and <code>S</code></p> <ul> <li><p><code>Zero</code> should have no fields</p> <li><p><code>S</code> should have a single parameter <code>P &lt;: PeanoNumber</code>, and a single field of type <code>P</code></p> </ul> <li><p>You should define <code>&#43;</code>, <code>*</code>, and <code>&#61;&#61;</code> &#40;equality&#41;</p> <li><p>You should also define <code>convert&#40;::Type&#123;Int&#125;, ...&#41;</code> to turn the Peano numbers into regular ints.</p> <li><p>The opposite conversion has been done for you</p> <li><p>HINT: Think recursively&#33; Remember dispatch&#33;</p> <li><p>HINT: Don&#39;t try to use too large of numbers. You&#39;ll find you&#39;re implementing arithmetic <em>in the type system</em>, so this can work the compiler pretty hard&#33;</p> </ul> <footer> <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </footer> </div> </main> <script src="/julia-workshop/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>